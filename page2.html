<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Christmas</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: Segoe UI, sans-serif;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
      }
      #ui-layer {
        position: absolute;
        bottom: 25px;
        width: 100%;
        text-align: center;
        z-index: 10;
        pointer-events: none;
      }
      .badge {
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid gold;
        color: gold;
        padding: 10px 25px;
        border-radius: 40px;
        display: inline-block;
        margin-bottom: 8px;
      }
      .guide {
        font-size: 13px;
        color: #ccc;
      }
      button {
        pointer-events: auto;
        margin-top: 10px;
        padding: 14px 40px;
        border-radius: 30px;
        font-weight: bold;
        border: 2px solid gold;
        background: linear-gradient(#d32f2f, #8b0000);
        color: white;
      }
    </style>
  </head>

  <body>
    <div id="ui-layer">
      <div id="status" class="badge">ðŸŽ„ Merry Christmas ðŸŽ„</div>
      <div class="guide">
        Move: Xoay | Click: Bung | Double: áº¢nh | Right: Thu
      </div>
      <button id="btnStart">Start</button>
    </div>

    <div id="canvas-container"></div>

    <script>
      // ================= CONFIG =================
      const CONFIG = {
        goldCount: 2000,
        redCount: 300,
        giftCount: 150,
        explodeRadius: 65,
        photoOrbitRadius: 25,
        treeHeight: 70,
        treeBaseRadius: 35,
        heartSize: 40,
      };

      const photoFiles = ["./q.jfif", "./d.jfif", "./k.jfif", "./h.jfif"];

      // ================= GLOBAL =================
      let scene, camera, renderer;
      let groupGold, groupRed, groupGift;
      let photoMeshes = [];
      let titleMesh, starMesh;
      let state = "TREE";
      let selectedIndex = 0;
      let mouseX = 0.5;
      let holding = false;

      // ================= MUSIC =================
      const music = new Audio("./piano.mp3");
      music.loop = true;
      // ================= TEXTURES =================
      const loader = new THREE.TextureLoader();
      const photoTextures = photoFiles.map((f) => loader.load(f));

      function glowTexture(color) {
        const c = document.createElement("canvas");
        c.width = c.height = 128;
        const ctx = c.getContext("2d");
        const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 50);
        g.addColorStop(0, color);
        g.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, 128, 128);
        return new THREE.CanvasTexture(c);
      }

      const textures = {
        gold: glowTexture("#FFD700"),
        red: glowTexture("#FF0000"),
        gift: glowTexture("#D32F2F"),
      };

      // ================= INIT =================
      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          60,
          innerWidth / innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document
          .getElementById("canvas-container")
          .appendChild(renderer.domElement);

        groupGold = createParticles("gold", CONFIG.goldCount, 2);
        groupRed = createParticles("red", CONFIG.redCount, 3);
        groupGift = createParticles("gift", CONFIG.giftCount, 3);

        createPhotos();
        createDecorations();
        animate();
      }

      // ================= PARTICLES =================
      function createParticles(type, count, size) {
        const pos = [],
          tree = [],
          explode = [],
          heart = [];
        for (let i = 0; i < count; i++) {
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          const r =
            (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius * Math.random();
          const a = Math.random() * Math.PI * 2;
          const x = r * Math.cos(a),
            z = r * Math.sin(a);

          pos.push(x, y, z);
          tree.push(x, y, z);

          const er = CONFIG.explodeRadius * Math.cbrt(Math.random());
          explode.push(
            er * (Math.random() - 0.5),
            er * (Math.random() - 0.5),
            er * (Math.random() - 0.5)
          );

          const t = Math.random() * Math.PI * 2;
          heart.push(
            CONFIG.heartSize * Math.sin(t) ** 3,
            (CONFIG.heartSize *
              (13 * Math.cos(t) -
                5 * Math.cos(2 * t) -
                2 * Math.cos(3 * t) -
                Math.cos(4 * t))) /
              16,
            (Math.random() - 0.5) * 10
          );
        }

        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
        g.userData = { tree, explode, heart };

        const m = new THREE.PointsMaterial({
          size,
          map: textures[type],
          transparent: true,
          blending:
            type === "gift" ? THREE.NormalBlending : THREE.AdditiveBlending,
          depthWrite: false,
        });

        const p = new THREE.Points(g, m);
        scene.add(p);
        return p;
      }

      // ================= PHOTOS =================
      function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        photoTextures.forEach((tex) => {
          const m = new THREE.MeshBasicMaterial({
            map: tex,
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geo, m);
          mesh.visible = false;
          mesh.scale.set(0, 0, 0);
          scene.add(mesh);
          photoMeshes.push(mesh);
        });
      }

      // ================= DECOR =================
      function createDecorations() {
        // Title
        const c = document.createElement("canvas");
        c.width = 1024;
        c.height = 256;
        const ctx = c.getContext("2d");
        ctx.font = "bold italic 90px serif";
        ctx.fillStyle = "#FFD700";
        ctx.textAlign = "center";
        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 30;
        ctx.fillText("MERRY CHRISTMAS", 512, 150);

        titleMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(60, 15),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(c),
            transparent: true,
          })
        );
        titleMesh.position.y = 50;
        scene.add(titleMesh);

        // Star
        const sc = document.createElement("canvas");
        sc.width = sc.height = 128;
        const sctx = sc.getContext("2d");
        sctx.fillStyle = "yellow";
        sctx.shadowColor = "white";
        sctx.shadowBlur = 20;
        sctx.beginPath();
        const cx = 64,
          cy = 64,
          o = 50,
          i = 20;
        for (let k = 0; k < 5; k++) {
          sctx.lineTo(
            cx + Math.cos(((18 + k * 72) * Math.PI) / 180) * o,
            cy - Math.sin(((18 + k * 72) * Math.PI) / 180) * o
          );
          sctx.lineTo(
            cx + Math.cos(((54 + k * 72) * Math.PI) / 180) * i,
            cy - Math.sin(((54 + k * 72) * Math.PI) / 180) * i
          );
        }
        sctx.closePath();
        sctx.fill();

        starMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(12, 12),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(sc),
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
        scene.add(starMesh);
      }

      // ================= UPDATE =================
      function updateGroup(g) {
        const arr = g.geometry.attributes.position.array;
        const t =
          g.geometry.userData[
            state === "TREE" ? "tree" : state === "HEART" ? "heart" : "explode"
          ];
        for (let i = 0; i < arr.length; i++) {
          arr[i] += (t[i] - arr[i]) * 0.06;
        }
        g.geometry.attributes.position.needsUpdate = true;
      }

      // ================= ANIMATE =================
      function animate() {
        requestAnimationFrame(animate);

        updateGroup(groupGold);
        updateGroup(groupRed);
        updateGroup(groupGift);

        const rot = (mouseX - 0.5) * 2.5;
        groupGold.rotation.y += (rot - groupGold.rotation.y) * 0.05;
        groupRed.rotation.y = groupGold.rotation.y;
        groupGift.rotation.y = groupGold.rotation.y;

        if (state === "TREE") {
          titleMesh.visible = true;
          starMesh.visible = true;
          starMesh.rotation.z -= 0.02;
          photoMeshes.forEach((m) => {
            m.visible = false;
          });
        }

        if (state === "EXPLODE") {
          titleMesh.visible = false;
          starMesh.visible = false;
          const base = groupGold.rotation.y;
          const step = (Math.PI * 2) / photoMeshes.length;
          let maxZ = -999;

          photoMeshes.forEach((m, i) => {
            m.visible = true;
            const a = base + i * step;
            const x = Math.sin(a) * CONFIG.photoOrbitRadius;
            const z = Math.cos(a) * CONFIG.photoOrbitRadius;
            const y = Math.sin(Date.now() * 0.001 + i) * 3;
            m.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            m.lookAt(camera.position);
            m.scale.lerp(new THREE.Vector3(0.8, 0.8, 0.8), 0.1);
            if (z > maxZ) {
              maxZ = z;
              selectedIndex = i;
            }
          });
        }

        if (state === "PHOTO") {
          photoMeshes.forEach((m, i) => {
            if (i === selectedIndex) {
              m.visible = true;
              m.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
              m.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
              m.lookAt(camera.position);
            } else {
              m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
          });
        }

        renderer.render(scene, camera);
      }

      // ================= MOUSE =================
      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX / innerWidth;
      });
      window.addEventListener("mousedown", (e) => {
        holding = true;
        if (e.button === 0) state = "EXPLODE";
        if (e.button === 2) state = "TREE";
      });
      window.addEventListener("mouseup", () => {
        holding = false;
        if (state === "HEART") state = "TREE";
      });

      window.addEventListener("dblclick", () => (state = "PHOTO"));
      window.addEventListener("contextmenu", (e) => e.preventDefault());

      // ================= START =================
      document.getElementById("btnStart").onclick = () => {
        music.play();
        init();
        document.getElementById("btnStart").style.display = "none";
      };

      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
